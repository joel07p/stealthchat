{
  "version": 3,
  "sources": ["../../crypto-ts/node_modules/tslib/tslib.es6.js", "../../src/enc/Hex.ts", "../../src/lib/WordArray.ts", "../../src/enc/Latin1.ts", "../../src/enc/Utf8.ts", "../../src/lib/BufferedBlockAlgorithm.ts", "../../src/lib/Base.ts", "../../src/lib/CipherParams.ts", "../../src/enc/Base64.ts", "../../src/format/OpenSSL.ts", "../../src/lib/SerializableCipher.ts", "../../src/lib/Hasher.ts", "../../src/algo/MD5.ts", "../../src/algo/EvpKDF.ts", "../../src/kdf/OpenSSLKdf.ts", "../../src/lib/PasswordBasedCipher.ts", "../../src/lib/Cipher.ts", "../../src/mode/BlockCipherModeAlgorithm.ts", "../../src/mode/BlockCipherMode.ts", "../../src/mode/CBCEncryptor.ts", "../../src/mode/CBCDecryptor.ts", "../../src/mode/CBC.ts", "../../src/pad/PKCS7.ts", "../../src/lib/BlockCipher.ts", "../../src/algo/AES.ts", "../../src/algo/SHA256.ts", "../../src/pad/NoPadding.ts", "../../src/mode/ECBEncryptor.ts", "../../src/mode/ECBDecryptor.ts", "../../src/mode/ECB.ts", "../../src/crypto-ts.ts"],
  "sourcesContent": ["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n", "import { Encoding } from './Encoding';\nimport { WordArray } from '../lib/WordArray';\n\nexport class Hex {\n    /**\n     * Converts a word array to a hex string.\n     *\n     * @param wordArray The word array.\n     *\n     * @return The hex string.\n     *\n     * @example\n     *\n     *     let hexString = Hex.stringify(wordArray);\n     */\n    public static stringify(wordArray: WordArray): string {\n        // Convert\n        const hexChars: Array<string> = [];\n        for (let i = 0; i < wordArray.sigBytes; i++) {\n            const bite = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n            hexChars.push((bite >>> 4).toString(16));\n            hexChars.push((bite & 0x0f).toString(16));\n        }\n\n        return hexChars.join('');\n    }\n\n    /**\n     * Converts a hex string to a word array.\n     *\n     * @param hexStr The hex string.\n     *\n     * @return The word array.\n     *\n     * @example\n     *\n     *     let wordArray = Hex.parse(hexString);\n     */\n    public static parse(hexStr: string): WordArray {\n        // Shortcut\n        const hexStrLength = hexStr.length;\n\n        // Convert\n        const words: Array<number> = [];\n        for (let i = 0; i < hexStrLength; i += 2) {\n            words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n        }\n\n        return new WordArray(words, hexStrLength / 2);\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Encoding = Hex;", "import { Encoding } from '../enc/Encoding';\nimport { Hex } from '../enc/Hex';\n\nexport class WordArray {\n    words: Array<number>;\n\n    sigBytes: number;\n\n    /**\n     * Creates a word array filled with random bytes.\n     *\n     * @param nBytes The number of random bytes to generate.\n     *\n     * @return The random word array.\n     *\n     * @example\n     *\n     *     let wordArray = WordArray.random(16);\n     */\n    public static random(nBytes: number) {\n        const words = [];\n\n        const r = (function(m_w: number) {\n            let m_z = 0x3ade68b1;\n\n            const mask = 0xffffffff;\n\n            return function() {\n                m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\n                m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\n                let result = ((m_z << 0x10) + m_w) & mask;\n                result /= 0x100000000;\n                result += 0.5;\n                return result * (Math.random() > .5 ? 1 : -1);\n            };\n        });\n\n        for(let i = 0, rcache; i < nBytes; i += 4) {\n            const _r = r((rcache || Math.random()) * 0x100000000);\n\n            rcache = _r() * 0x3ade67b7;\n            words.push((_r() * 0x100000000) | 0);\n        }\n\n        return new WordArray(words, nBytes);\n    }\n\n    /**\n     * Initializes a newly created word array.\n     *\n     * @param words (Optional) An array of 32-bit words.\n     * @param sigBytes (Optional) The number of significant bytes in the words.\n     *\n     * @example\n     *\n     *     let wordArray = new WordArray();\n     *     let wordArray = new WordArray([0x00010203, 0x04050607]);\n     *     let wordArray = new WordArray([0x00010203, 0x04050607], 6);\n     */\n    constructor(words?: Array<number>, sigBytes?: number) {\n        this.words = words || [];\n\n        if(sigBytes !== undefined) {\n            this.sigBytes = sigBytes;\n        } else {\n            this.sigBytes = this.words.length * 4;\n        }\n    }\n\n    /**\n     * Converts this word array to a string.\n     *\n     * @param encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n     *\n     * @return The stringified word array.\n     *\n     * @example\n     *\n     *     let string = wordArray + '';\n     *     let string = wordArray.toString();\n     *     let string = wordArray.toString(CryptoJS.enc.Utf8);\n     */\n    toString(encoder?: Encoding): string {\n        return (encoder || Hex).stringify(this);\n    }\n\n    /**\n     * Concatenates a word array to this word array.\n     *\n     * @param wordArray The word array to append.\n     *\n     * @return This word array.\n     *\n     * @example\n     *\n     *     wordArray1.concat(wordArray2);\n     */\n    concat(wordArray: WordArray): WordArray {\n        // Clamp excess bits\n        this.clamp();\n\n        // Concat\n        if(this.sigBytes % 4) {\n            // Copy one byte at a time\n            for(let i = 0; i < wordArray.sigBytes; i++) {\n                const thatByte = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                this.words[(this.sigBytes + i) >>> 2] |= thatByte << (24 - ((this.sigBytes + i) % 4) * 8);\n            }\n        } else {\n            // Copy one word at a time\n            for (let i = 0; i < wordArray.sigBytes; i += 4) {\n                this.words[(this.sigBytes + i) >>> 2] = wordArray.words[i >>> 2];\n            }\n        }\n        this.sigBytes += wordArray.sigBytes;\n\n        // Chainable\n        return this;\n    }\n\n    /**\n     * Removes insignificant bits.\n     *\n     * @example\n     *\n     *     wordArray.clamp();\n     */\n    clamp() {\n        // Clamp\n        this.words[this.sigBytes >>> 2] &= 0xffffffff << (32 - (this.sigBytes % 4) * 8);\n        this.words.length = Math.ceil(this.sigBytes / 4);\n    }\n\n    /**\n     * Creates a copy of this word array.\n     *\n     * @return The clone.\n     *\n     * @example\n     *\n     *     let clone = wordArray.clone();\n     */\n    clone(): WordArray {\n        return new WordArray(this.words.slice(0), this.sigBytes);\n    }\n}", "import { Encoding } from './Encoding';\nimport { WordArray } from '../lib/WordArray';\n\ndeclare function escape(s: string): string;\ndeclare function unescape(s: string): string;\n\nexport class Latin1 {\n    /**\n     * Converts a word array to a Latin1 string.\n     *\n     * @param wordArray The word array.\n     *\n     * @return The Latin1 string.\n     *\n     * @example\n     *\n     *     let latin1String = Latin1.stringify(wordArray);\n     */\n    public static stringify(wordArray: WordArray): string {\n        // Convert\n        const latin1Chars = [];\n        for (let i = 0; i < wordArray.sigBytes; i++) {\n            const bite = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n            latin1Chars.push(String.fromCharCode(bite));\n        }\n\n        return latin1Chars.join('');\n    }\n\n    /**\n     * Converts a Latin1 string to a word array.\n     *\n     * @param latin1Str The Latin1 string.\n     *\n     * @return The word array.\n     *\n     * @example\n     *\n     *     let wordArray = Latin1.parse(latin1String);\n     */\n    public static parse(latin1Str: string): WordArray {\n        // Shortcut\n        const latin1StrLength = latin1Str.length;\n\n        // Convert\n        const words: Array<number> = [];\n        for (let i = 0; i < latin1StrLength; i++) {\n            words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n        }\n\n        return new WordArray(words, latin1StrLength);\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Encoding = Latin1;", "import { Encoding } from './Encoding';\nimport { WordArray } from '../lib/WordArray';\nimport { Latin1 } from './Latin1';\n\nexport class Utf8 {\n    /**\n     * Converts a word array to a UTF-8 string.\n     *\n     * @param wordArray The word array.\n     *\n     * @return The UTF-8 string.\n     *\n     * @example\n     *\n     *     let utf8String = Utf8.stringify(wordArray);\n     */\n    public static stringify(wordArray: WordArray): string {\n        try {\n            return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n        } catch(e) {\n            throw new Error('Malformed UTF-8 data');\n        }\n    }\n\n    /**\n     * Converts a UTF-8 string to a word array.\n     *\n     * @param utf8Str The UTF-8 string.\n     *\n     * @return The word array.\n     *\n     * @example\n     *\n     *     let wordArray = Utf8.parse(utf8String);\n     */\n    public static parse(utf8Str: string): WordArray {\n        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Encoding = Utf8;", "import { WordArray } from '../lib/WordArray';\nimport { Utf8 } from '../enc/Utf8';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\n\nexport abstract class BufferedBlockAlgorithm {\n    public _minBufferSize = 0;\n\n    public _data: WordArray;\n\n    public _nDataBytes: number;\n\n    public cfg: BufferedBlockAlgorithmConfig;\n\n    abstract _doProcessBlock(wordArray: Array<number>, offset: number): void;\n\n    constructor(cfg?: BufferedBlockAlgorithmConfig) {\n        this.cfg = Object.assign({\n            blockSize: 1\n        }, cfg);\n\n        // Initial values\n        this._data = new WordArray();\n        this._nDataBytes = 0;\n    }\n\n    /**\n     * Resets this block algorithm's data buffer to its initial state.\n     *\n     * @example\n     *\n     *     bufferedBlockAlgorithm.reset();\n     */\n    reset() {\n        // Initial values\n        this._data = new WordArray();\n        this._nDataBytes = 0;\n    }\n\n    /**\n     * Adds new data to this block algorithm's buffer.\n     *\n     * @param data The data to append. Strings are converted to a WordArray using UTF-8.\n     *\n     * @example\n     *\n     *     bufferedBlockAlgorithm._append('data');\n     *     bufferedBlockAlgorithm._append(wordArray);\n     */\n    _append(data: string | WordArray) {\n        // Convert string to WordArray, else assume WordArray already\n        if(typeof data === 'string') {\n            data = Utf8.parse(data);\n        }\n\n        // Append\n        this._data.concat(data);\n        this._nDataBytes += data.sigBytes;\n    }\n\n    /**\n     * Processes available data blocks.\n     *\n     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n     *\n     * @param doFlush Whether all blocks and partial blocks should be processed.\n     *\n     * @return The processed data.\n     *\n     * @example\n     *\n     *     let processedData = bufferedBlockAlgorithm._process();\n     *     let processedData = bufferedBlockAlgorithm._process(!!'flush');\n     */\n    _process(doFlush?: boolean): WordArray {\n        if(!this.cfg.blockSize) {\n            throw new Error('missing blockSize in config');\n        }\n\n        // Shortcuts\n        const blockSizeBytes = this.cfg.blockSize * 4;\n\n        // Count blocks ready\n        let nBlocksReady = this._data.sigBytes / blockSizeBytes;\n        if (doFlush) {\n            // Round up to include partial blocks\n            nBlocksReady = Math.ceil(nBlocksReady);\n        } else {\n            // Round down to include only full blocks,\n            // less the number of blocks that must remain in the buffer\n            nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n        }\n\n        // Count words ready\n        const nWordsReady = nBlocksReady * this.cfg.blockSize;\n\n        // Count bytes ready\n        const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n\n        // Process blocks\n        let processedWords;\n        if (nWordsReady) {\n            for (let offset = 0; offset < nWordsReady; offset += this.cfg.blockSize) {\n                // Perform concrete-algorithm logic\n                this._doProcessBlock(this._data.words, offset);\n            }\n\n            // Remove processed words\n            processedWords = this._data.words.splice(0, nWordsReady);\n            this._data.sigBytes -= nBytesReady;\n        }\n\n        // Return processed words\n        return new WordArray(processedWords, nBytesReady);\n    }\n\n    /**\n     * Creates a copy of this object.\n     *\n     * @return The clone.\n     *\n     * @example\n     *\n     *     let clone = bufferedBlockAlgorithm.clone();\n     */\n    clone(): BufferedBlockAlgorithm {\n        const clone = this.constructor();\n\n        for(const attr in this) {\n            if(this.hasOwnProperty(attr)) {\n                clone[attr] = this[attr];\n            }\n        }\n\n        clone._data = this._data.clone();\n\n        return clone;\n    }\n}", "export class Base {\n}", "import { Base } from '../lib/Base';\nimport { CipherParamsInterface } from './CipherParamsInterface';\nimport { WordArray } from '../lib/WordArray';\nimport { Cipher } from '../lib/Cipher';\nimport { BlockCipherMode } from '../mode/BlockCipherMode';\nimport { Padding } from '../pad/Padding';\nimport { Formatter } from '../format/Formatter';\n\nexport class CipherParams extends Base implements CipherParamsInterface {\n    ciphertext?: WordArray;\n\n    key?: WordArray | string;\n\n    iv?: WordArray;\n\n    salt?: WordArray | string;\n\n    algorithm?: typeof Cipher;\n\n    mode?: typeof BlockCipherMode;\n\n    padding?: Padding;\n\n    blockSize?: number;\n\n    formatter?: Formatter;\n\n    /**\n     * Initializes a newly created cipher params object.\n     *\n     * @param cipherParams An object with any of the possible cipher parameters.\n     *\n     * @example\n     *\n     *     let cipherParams = CipherParams.create({\n     *         ciphertext: ciphertextWordArray,\n     *         key: keyWordArray,\n     *         iv: ivWordArray,\n     *         salt: saltWordArray,\n     *         algorithm: AESAlgorithm,\n     *         mode: CBC,\n     *         padding: PKCS7,\n     *         blockSize: 4,\n     *         formatter: OpenSSLFormatter\n     *     });\n     */\n    public constructor(cipherParams: CipherParamsInterface) {\n        super();\n\n        this.ciphertext = cipherParams.ciphertext;\n        this.key = cipherParams.key;\n        this.iv = cipherParams.iv;\n        this.salt = cipherParams.salt;\n        this.algorithm = cipherParams.algorithm;\n        this.mode = cipherParams.mode;\n        this.padding = cipherParams.padding;\n        this.blockSize = cipherParams.blockSize;\n        this.formatter = cipherParams.formatter;\n    }\n\n    public extend(additionalParams: CipherParams): CipherParams {\n        if(additionalParams.ciphertext !== undefined) {\n            this.ciphertext = additionalParams.ciphertext;\n        }\n\n        if(additionalParams.key !== undefined) {\n            this.key = additionalParams.key;\n        }\n\n        if(additionalParams.iv !== undefined) {\n            this.iv = additionalParams.iv;\n        }\n\n        if(additionalParams.salt !== undefined) {\n            this.salt = additionalParams.salt;\n        }\n\n        if(additionalParams.algorithm !== undefined) {\n            this.algorithm = additionalParams.algorithm;\n        }\n\n        if(additionalParams.mode !== undefined) {\n            this.mode = additionalParams.mode;\n        }\n\n        if(additionalParams.padding !== undefined) {\n            this.padding = additionalParams.padding;\n        }\n\n        if(additionalParams.blockSize !== undefined) {\n            this.blockSize = additionalParams.blockSize;\n        }\n\n        if(additionalParams.formatter !== undefined) {\n            this.formatter = additionalParams.formatter;\n        }\n\n\n        return this;\n    }\n\n    /**\n     * Converts this cipher params object to a string.\n     *\n     * @param formatter (Optional) The formatting strategy to use.\n     *\n     * @return The stringified cipher params.\n     *\n     * @throws Error If neither the formatter nor the default formatter is set.\n     *\n     * @example\n     *\n     *     let string = cipherParams + '';\n     *     let string = cipherParams.toString();\n     *     let string = cipherParams.toString(CryptoJS.format.OpenSSL);\n     */\n    public toString(formatter?: Formatter): string {\n        if(formatter) {\n            return formatter.stringify(this);\n        } else if(this.formatter) {\n            return this.formatter.stringify(this);\n        } else {\n            throw new Error('cipher needs a formatter to be able to convert the result into a string');\n        }\n    }\n}", "import { Encoding } from './Encoding';\nimport { WordArray } from '../lib/WordArray';\n\nexport class Base64 {\n    public static _map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n    public static _reverseMap: Array<number> | undefined = undefined;\n\n    /**\n     * Converts a word array to a Base64 string.\n     *\n     * @param wordArray The word array.\n     *\n     * @return The Base64 string.\n     *\n     * @example\n     *\n     *     let base64String = Base64.stringify(wordArray);\n     */\n    public static stringify(wordArray: WordArray): string {\n        // Clamp excess bits\n        wordArray.clamp();\n\n        // Convert\n        const base64Chars = [];\n        for (let i = 0; i < wordArray.sigBytes; i += 3) {\n            const byte1 = (wordArray.words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n            const byte2 = (wordArray.words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n            const byte3 = (wordArray.words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n            const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n            for (let j = 0; (j < 4) && (i + j * 0.75 < wordArray.sigBytes); j++) {\n                base64Chars.push(this._map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n            }\n        }\n\n        // Add padding\n        const paddingChar = this._map.charAt(64);\n        if (paddingChar) {\n            while (base64Chars.length % 4) {\n                base64Chars.push(paddingChar);\n            }\n        }\n\n        return base64Chars.join('');\n    }\n\n    /**\n     * Converts a Base64 string to a word array.\n     *\n     * @param base64Str The Base64 string.\n     *\n     * @return The word array.\n     *\n     * @example\n     *\n     *     let wordArray = Base64.parse(base64String);\n     */\n    public static parse(base64Str: string): WordArray {\n        // Shortcuts\n        let base64StrLength = base64Str.length;\n\n        if(this._reverseMap === undefined) {\n                this._reverseMap = [];\n                for(let j = 0; j < this._map.length; j++) {\n                    this._reverseMap[this._map.charCodeAt(j)] = j;\n                }\n        }\n\n        // Ignore padding\n        const paddingChar = this._map.charAt(64);\n        if(paddingChar) {\n            const paddingIndex = base64Str.indexOf(paddingChar);\n            if(paddingIndex !== -1) {\n                base64StrLength = paddingIndex;\n            }\n        }\n\n        // Convert\n        return this.parseLoop(base64Str, base64StrLength, this._reverseMap);\n    }\n\n    public static parseLoop(base64Str: string, base64StrLength: number, reverseMap: Array<number>): WordArray {\n        const words: Array<number> = [];\n        let nBytes = 0;\n        for(let i = 0; i < base64StrLength; i++) {\n            if(i % 4) {\n                const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n                const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n                words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);\n                nBytes++;\n            }\n        }\n\n        return new WordArray(words, nBytes);\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Encoding = Base64;", "import { Formatter } from './Formatter';\nimport { CipherParams } from '../lib/CipherParams';\nimport { WordArray } from '../lib/WordArray';\nimport { Base64 } from '../enc/Base64';\n\nexport class OpenSSL {\n    /**\n     * Converts a cipher params object to an OpenSSL-compatible string.\n     *\n     * @param cipherParams The cipher params object.\n     *\n     * @return The OpenSSL-compatible string.\n     *\n     * @example\n     *\n     *     let openSSLString = OpenSSLFormatter.stringify(cipherParams);\n     */\n    public static stringify(cipherParams: CipherParams): string {\n        if(!cipherParams.ciphertext) {\n            throw new Error('missing ciphertext in params');\n        }\n\n        // Shortcuts\n        const ciphertext = cipherParams.ciphertext;\n        const salt = cipherParams.salt;\n\n        // Format\n        let wordArray: WordArray;\n        if(salt) {\n            if(typeof salt === 'string') {\n                throw new Error('salt is expected to be a WordArray');\n            }\n\n            wordArray = (new WordArray([0x53616c74, 0x65645f5f])).concat(salt).concat(ciphertext);\n        } else {\n            wordArray = ciphertext;\n        }\n\n        return wordArray.toString(Base64);\n    }\n\n    /**\n     * Converts an OpenSSL-compatible string to a cipher params object.\n     *\n     * @param openSSLStr The OpenSSL-compatible string.\n     *\n     * @return The cipher params object.\n     *\n     * @example\n     *\n     *     let cipherParams = OpenSSLFormatter.parse(openSSLString);\n     */\n    public static parse(openSSLStr: string): CipherParams {\n        // Parse base64\n        const ciphertext = Base64.parse(openSSLStr);\n\n        // Test for salt\n        let salt: WordArray | undefined;\n        if(ciphertext.words[0] === 0x53616c74 && ciphertext.words[1] === 0x65645f5f) {\n            // Extract salt\n            salt = new WordArray(ciphertext.words.slice(2, 4));\n\n            // Remove salt from ciphertext\n            ciphertext.words.splice(0, 4);\n            ciphertext.sigBytes -= 16;\n        }\n\n        return new CipherParams({ ciphertext: ciphertext, salt: salt });\n    }\n}\n\n// type guard for OpenSSL formatter (to ensure it has the required static methods)\nconst _: Formatter = OpenSSL;", "import { WordArray } from './WordArray';\nimport { Cipher } from './Cipher';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\nimport { OpenSSL } from '../format/OpenSSL';\nimport { CipherParams } from './CipherParams';\nimport { Formatter } from '../format/Formatter';\n\nexport class SerializableCipher {\n    public static cfg: BufferedBlockAlgorithmConfig = {\n        blockSize: 4,\n        iv: new WordArray([]),\n        format: OpenSSL\n    };\n\n    /**\n     * Encrypts a message.\n     *\n     * @param cipher The cipher algorithm to use.\n     * @param message The message to encrypt.\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return A cipher params object.\n     *\n     * @example\n     *\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, {\n     *       iv: iv,\n     *       format: CryptoJS.format.OpenSSL\n     *     });\n     */\n    public static encrypt(\n        cipher: typeof Cipher,\n        message: WordArray | string,\n        key: WordArray,\n        cfg?: BufferedBlockAlgorithmConfig\n    ): CipherParams {\n        // Apply config defaults\n        const config = Object.assign({}, this.cfg, cfg);\n\n        // Encrypt\n        const encryptor = cipher.createEncryptor(key, config);\n        const ciphertext = encryptor.finalize(message);\n\n        // Create and return serializable cipher params\n        return new CipherParams({\n            ciphertext: ciphertext,\n            key: key,\n            iv: encryptor.cfg.iv,\n            algorithm: cipher,\n            mode: (<any> encryptor.cfg).mode,\n            padding: (<any> encryptor.cfg).padding,\n            blockSize: encryptor.cfg.blockSize,\n            formatter: config.format\n        });\n    }\n\n    /**\n     * Decrypts serialized ciphertext.\n     *\n     * @param cipher The cipher algorithm to use.\n     * @param ciphertext The ciphertext to decrypt.\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return The plaintext.\n     *\n     * @example\n     *\n     *     let plaintext = SerializableCipher.decrypt(\n     *         AESAlgorithm,\n     *         formattedCiphertext,\n     *         key, {\n     *             iv: iv,\n     *             format: CryptoJS.format.OpenSSL\n     *         }\n     *     );\n     *\n     *     let plaintext = SerializableCipher.decrypt(\n     *         AESAlgorithm,\n     *         ciphertextParams,\n     *         key, {\n     *             iv: iv,\n     *             format: CryptoJS.format.OpenSSL\n     *         }\n     *     );\n     */\n    public static decrypt(\n        cipher: typeof Cipher,\n        ciphertext: CipherParams | string,\n        key: WordArray,\n        optionalCfg?: BufferedBlockAlgorithmConfig\n    ): WordArray {\n        // Apply config defaults\n        const cfg = Object.assign({}, this.cfg, optionalCfg);\n\n        if(!cfg.format) {\n            throw new Error('could not determine format');\n        }\n\n        // Convert string to CipherParams\n        ciphertext = this._parse(ciphertext, cfg.format);\n\n        if(!ciphertext.ciphertext) {\n            throw new Error('could not determine ciphertext');\n        }\n\n        // Decrypt\n        const plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n\n        return plaintext;\n    }\n\n    /**\n     * Converts serialized ciphertext to CipherParams,\n     * else assumed CipherParams already and returns ciphertext unchanged.\n     *\n     * @param ciphertext The ciphertext.\n     * @param format The formatting strategy to use to parse serialized ciphertext.\n     *\n     * @return The unserialized ciphertext.\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n     */\n    public static _parse(ciphertext: CipherParams | string, format: Formatter): CipherParams {\n        if(typeof ciphertext === 'string') {\n            return format.parse(ciphertext);\n        } else {\n            return ciphertext;\n        }\n    }\n}", "import { BufferedBlockAlgorithm } from '../lib/BufferedBlockAlgorithm';\nimport { BufferedBlockAlgorithmConfig } from '../lib/BufferedBlockAlgorithmConfig';\nimport { WordArray } from '../lib/WordArray';\n\nexport abstract class Hasher extends BufferedBlockAlgorithm {\n    /**\n     * Creates a shortcut function to a hasher's object interface.\n     *\n     * @param hasher The hasher to create a helper for.\n     *\n     * @return The shortcut function.\n     *\n     * @example\n     *\n     *     let SHA256 = Hasher._createHelper(SHA256);\n     */\n    public static _createHelper(hasher: typeof Hasher) {\n        function helper(message: WordArray | string, cfg?: BufferedBlockAlgorithmConfig) {\n            const hasherClass: any = hasher;\n\n            const hasherInstance: any = new hasherClass(cfg);\n\n            return hasherInstance.finalize(message);\n        }\n\n        return helper;\n    }\n\n    /**\n     * Initializes a newly created hasher.\n     *\n     * @param cfg (Optional) The configuration options to use for this hash computation.\n     *\n     * @example\n     *\n     *     let hasher = CryptoJS.algo.SHA256.create();\n     */\n    public constructor(cfg?: BufferedBlockAlgorithmConfig) {\n        // Apply config defaults\n        super(Object.assign({\n            blockSize: 512 / 32\n        }, cfg));\n\n        // Set initial values\n        this.reset();\n    }\n\n    /**\n     * Updates this hasher with a message.\n     *\n     * @param messageUpdate The message to append.\n     *\n     * @return This hasher.\n     *\n     * @example\n     *\n     *     hasher.update('message');\n     *     hasher.update(wordArray);\n     */\n    update(messageUpdate: WordArray | string): Hasher {\n        // Append\n        this._append(messageUpdate);\n\n        // Update the hash\n        this._process();\n\n        // Chainable\n        return this;\n    }\n\n    /**\n     * Finalizes the hash computation.\n     * Note that the finalize operation is effectively a destructive, read-once operation.\n     *\n     * @param messageUpdate (Optional) A final message update.\n     *\n     * @return The hash.\n     *\n     * @example\n     *\n     *     let hash = hasher.finalize();\n     *     let hash = hasher.finalize('message');\n     *     let hash = hasher.finalize(wordArray);\n     */\n    public finalize(messageUpdate: WordArray | string): WordArray {\n        // Final message update\n        if(messageUpdate) {\n            this._append(messageUpdate);\n        }\n\n        // Perform concrete-hasher logic\n        const hash = this._doFinalize();\n\n        return hash;\n    }\n\n    public abstract _doFinalize(): WordArray;\n}", "import { Hasher } from '../lib/Hasher';\nimport { WordArray } from '../lib/WordArray';\n\n// Constants table\nconst T: Array<number> = [];\n\n// Compute constants\nfor(let i = 0; i < 64; i++) {\n    T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n}\n\nexport class MD5 extends Hasher {\n    public _hash!: WordArray;\n\n    public static FF(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n        const n = a + ((b & c) | (~b & d)) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    }\n\n    public static GG(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n        const n = a + ((b & d) | (c & ~d)) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    }\n\n    public static HH(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n        const n = a + (b ^ c ^ d) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    }\n\n    public static II(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n        const n = a + (c ^ (b | ~d)) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    }\n\n    public reset() {\n        // reset core values\n        super.reset();\n\n        this._hash = new WordArray([\n            0x67452301, 0xefcdab89,\n            0x98badcfe, 0x10325476\n        ]);\n    }\n\n    public _doProcessBlock(M: Array<number>, offset: number) {\n        // Swap endian\n        for(let i = 0; i < 16; i++) {\n            // Shortcuts\n            const offset_i = offset + i;\n            const M_offset_i = M[offset_i];\n\n            M[offset_i] = (\n                (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n                (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n            );\n        }\n\n        // Shortcuts\n        const H = this._hash.words;\n\n        const M_offset_0  = M[offset + 0];\n        const M_offset_1  = M[offset + 1];\n        const M_offset_2  = M[offset + 2];\n        const M_offset_3  = M[offset + 3];\n        const M_offset_4  = M[offset + 4];\n        const M_offset_5  = M[offset + 5];\n        const M_offset_6  = M[offset + 6];\n        const M_offset_7  = M[offset + 7];\n        const M_offset_8  = M[offset + 8];\n        const M_offset_9  = M[offset + 9];\n        const M_offset_10 = M[offset + 10];\n        const M_offset_11 = M[offset + 11];\n        const M_offset_12 = M[offset + 12];\n        const M_offset_13 = M[offset + 13];\n        const M_offset_14 = M[offset + 14];\n        const M_offset_15 = M[offset + 15];\n\n        // Working variables\n        let a = H[0];\n        let b = H[1];\n        let c = H[2];\n        let d = H[3];\n\n        // Computation\n        a = MD5.FF(a, b, c, d, M_offset_0,  7,  T[0]);\n        d = MD5.FF(d, a, b, c, M_offset_1,  12, T[1]);\n        c = MD5.FF(c, d, a, b, M_offset_2,  17, T[2]);\n        b = MD5.FF(b, c, d, a, M_offset_3,  22, T[3]);\n        a = MD5.FF(a, b, c, d, M_offset_4,  7,  T[4]);\n        d = MD5.FF(d, a, b, c, M_offset_5,  12, T[5]);\n        c = MD5.FF(c, d, a, b, M_offset_6,  17, T[6]);\n        b = MD5.FF(b, c, d, a, M_offset_7,  22, T[7]);\n        a = MD5.FF(a, b, c, d, M_offset_8,  7,  T[8]);\n        d = MD5.FF(d, a, b, c, M_offset_9,  12, T[9]);\n        c = MD5.FF(c, d, a, b, M_offset_10, 17, T[10]);\n        b = MD5.FF(b, c, d, a, M_offset_11, 22, T[11]);\n        a = MD5.FF(a, b, c, d, M_offset_12, 7,  T[12]);\n        d = MD5.FF(d, a, b, c, M_offset_13, 12, T[13]);\n        c = MD5.FF(c, d, a, b, M_offset_14, 17, T[14]);\n        b = MD5.FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n        a = MD5.GG(a, b, c, d, M_offset_1,  5,  T[16]);\n        d = MD5.GG(d, a, b, c, M_offset_6,  9,  T[17]);\n        c = MD5.GG(c, d, a, b, M_offset_11, 14, T[18]);\n        b = MD5.GG(b, c, d, a, M_offset_0,  20, T[19]);\n        a = MD5.GG(a, b, c, d, M_offset_5,  5,  T[20]);\n        d = MD5.GG(d, a, b, c, M_offset_10, 9,  T[21]);\n        c = MD5.GG(c, d, a, b, M_offset_15, 14, T[22]);\n        b = MD5.GG(b, c, d, a, M_offset_4,  20, T[23]);\n        a = MD5.GG(a, b, c, d, M_offset_9,  5,  T[24]);\n        d = MD5.GG(d, a, b, c, M_offset_14, 9,  T[25]);\n        c = MD5.GG(c, d, a, b, M_offset_3,  14, T[26]);\n        b = MD5.GG(b, c, d, a, M_offset_8,  20, T[27]);\n        a = MD5.GG(a, b, c, d, M_offset_13, 5,  T[28]);\n        d = MD5.GG(d, a, b, c, M_offset_2,  9,  T[29]);\n        c = MD5.GG(c, d, a, b, M_offset_7,  14, T[30]);\n        b = MD5.GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n        a = MD5.HH(a, b, c, d, M_offset_5,  4,  T[32]);\n        d = MD5.HH(d, a, b, c, M_offset_8,  11, T[33]);\n        c = MD5.HH(c, d, a, b, M_offset_11, 16, T[34]);\n        b = MD5.HH(b, c, d, a, M_offset_14, 23, T[35]);\n        a = MD5.HH(a, b, c, d, M_offset_1,  4,  T[36]);\n        d = MD5.HH(d, a, b, c, M_offset_4,  11, T[37]);\n        c = MD5.HH(c, d, a, b, M_offset_7,  16, T[38]);\n        b = MD5.HH(b, c, d, a, M_offset_10, 23, T[39]);\n        a = MD5.HH(a, b, c, d, M_offset_13, 4,  T[40]);\n        d = MD5.HH(d, a, b, c, M_offset_0,  11, T[41]);\n        c = MD5.HH(c, d, a, b, M_offset_3,  16, T[42]);\n        b = MD5.HH(b, c, d, a, M_offset_6,  23, T[43]);\n        a = MD5.HH(a, b, c, d, M_offset_9,  4,  T[44]);\n        d = MD5.HH(d, a, b, c, M_offset_12, 11, T[45]);\n        c = MD5.HH(c, d, a, b, M_offset_15, 16, T[46]);\n        b = MD5.HH(b, c, d, a, M_offset_2,  23, T[47]);\n\n        a = MD5.II(a, b, c, d, M_offset_0,  6,  T[48]);\n        d = MD5.II(d, a, b, c, M_offset_7,  10, T[49]);\n        c = MD5.II(c, d, a, b, M_offset_14, 15, T[50]);\n        b = MD5.II(b, c, d, a, M_offset_5,  21, T[51]);\n        a = MD5.II(a, b, c, d, M_offset_12, 6,  T[52]);\n        d = MD5.II(d, a, b, c, M_offset_3,  10, T[53]);\n        c = MD5.II(c, d, a, b, M_offset_10, 15, T[54]);\n        b = MD5.II(b, c, d, a, M_offset_1,  21, T[55]);\n        a = MD5.II(a, b, c, d, M_offset_8,  6,  T[56]);\n        d = MD5.II(d, a, b, c, M_offset_15, 10, T[57]);\n        c = MD5.II(c, d, a, b, M_offset_6,  15, T[58]);\n        b = MD5.II(b, c, d, a, M_offset_13, 21, T[59]);\n        a = MD5.II(a, b, c, d, M_offset_4,  6,  T[60]);\n        d = MD5.II(d, a, b, c, M_offset_11, 10, T[61]);\n        c = MD5.II(c, d, a, b, M_offset_2,  15, T[62]);\n        b = MD5.II(b, c, d, a, M_offset_9,  21, T[63]);\n\n        // Intermediate hash value\n        H[0] = (H[0] + a) | 0;\n        H[1] = (H[1] + b) | 0;\n        H[2] = (H[2] + c) | 0;\n        H[3] = (H[3] + d) | 0;\n    }\n\n    public _doFinalize(): WordArray {\n        // Shortcuts\n        const data = this._data;\n        const dataWords = data.words;\n\n        const nBitsTotal = this._nDataBytes * 8;\n        const nBitsLeft = data.sigBytes * 8;\n\n        // Add padding\n        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\n        const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n        const nBitsTotalL = nBitsTotal;\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n            (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n            (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)\n        );\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n            (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n            (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)\n        );\n\n        data.sigBytes = (dataWords.length + 1) * 4;\n\n        // Hash final blocks\n        this._process();\n\n        // Shortcuts\n        const hash = this._hash;\n        const H = hash.words;\n\n        // Swap endian\n        for (let i = 0; i < 4; i++) {\n            // Shortcut\n            const H_i = H[i];\n\n            H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n                   (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n        }\n\n        // Return final computed hash\n        return hash;\n    }\n}", "import { WordArray } from '../lib/WordArray';\nimport { Hasher } from '../lib/Hasher';\nimport { MD5 } from '../algo/MD5';\n\nexport interface OptionalEvpKDFConfig {\n    keySize?: number;\n    hasher?: typeof Hasher;\n    iterations?: number;\n}\n\nexport interface EvpKDFConfig extends OptionalEvpKDFConfig {\n    keySize: number;\n    hasher: typeof Hasher;\n    iterations: number;\n}\n\nexport class EvpKDF {\n    public cfg: EvpKDFConfig;\n\n    /**\n     * Initializes a newly created key derivation function.\n     *\n     * @param cfg (Optional) The configuration options to use for the derivation.\n     *\n     * @example\n     *\n     *     let kdf = EvpKDF.create();\n     *     let kdf = EvpKDF.create({ keySize: 8 });\n     *     let kdf = EvpKDF.create({ keySize: 8, iterations: 1000 });\n     */\n    constructor(cfg?: OptionalEvpKDFConfig) {\n        this.cfg = Object.assign({\n            keySize: 128 / 32,\n            hasher: MD5,\n            iterations: 1\n        }, cfg);\n    }\n\n    /**\n     * Derives a key from a password.\n     *\n     * @param password The password.\n     * @param salt A salt.\n     *\n     * @return The derived key.\n     *\n     * @example\n     *\n     *     let key = kdf.compute(password, salt);\n     */\n    compute(password: WordArray | string, salt: WordArray | string): WordArray {\n        // Init hasher\n        const hasher = new (<any> this.cfg.hasher)();\n\n        // Initial values\n        const derivedKey = new WordArray();\n\n        // Generate key\n        let block;\n        while(derivedKey.words.length < this.cfg.keySize) {\n            if(block) {\n                hasher.update(block);\n            }\n            block = hasher.update(password).finalize(salt);\n            hasher.reset();\n\n            // Iterations\n            for(let i = 1; i < this.cfg.iterations; i++) {\n                block = hasher.finalize(block);\n                hasher.reset();\n            }\n\n            derivedKey.concat(block);\n        }\n        derivedKey.sigBytes = this.cfg.keySize * 4;\n\n        return derivedKey;\n    }\n}", "import { KDF } from './KDF';\nimport { WordArray } from '../lib/WordArray';\nimport { CipherParams } from '../lib/CipherParams';\nimport { EvpKDF } from '../algo/EvpKDF';\n\nexport class OpenSSLKdf {\n    /**\n     * Derives a key and IV from a password.\n     *\n     * @param password The password to derive from.\n     * @param keySize The size in words of the key to generate.\n     * @param ivSize The size in words of the IV to generate.\n     * @param salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n     *\n     * @return A cipher params object with the key, IV, and salt.\n     *\n     * @example\n     *\n     *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32);\n     *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n     */\n    public static execute(password: string, keySize: number, ivSize: number, salt?: WordArray | string): CipherParams {\n        // Generate random salt\n        if(!salt) {\n            salt = WordArray.random(64 / 8);\n        }\n\n        // Derive key and IV\n        const key = (new EvpKDF({ keySize: keySize + ivSize })).compute(password, salt);\n\n        // Separate key and IV\n        const iv = new WordArray(key.words.slice(keySize), ivSize * 4);\n        key.sigBytes = keySize * 4;\n\n        // Return params\n        return new CipherParams({ key: key, iv: iv, salt: salt });\n    }\n}\n\nconst _: KDF = OpenSSLKdf;", "import { SerializableCipher } from './SerializableCipher';\nimport { WordArray } from './WordArray';\nimport { Cipher } from './Cipher';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\nimport { OpenSSL } from '../format/OpenSSL';\nimport { CipherParams } from './CipherParams';\nimport { Formatter } from '../format/Formatter';\nimport { OpenSSLKdf } from '../kdf/OpenSSLKdf';\n\nexport class PasswordBasedCipher {\n    public static cfg: BufferedBlockAlgorithmConfig = {\n        blockSize: 4,\n        iv: new WordArray([]),\n        format: OpenSSL,\n        kdf: OpenSSLKdf\n    };\n\n    /**\n     * Encrypts a message using a password.\n     *\n     * @param cipher The cipher algorithm to use.\n     * @param message The message to encrypt.\n     * @param password The password.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return A cipher params object.\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password');\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password', { format: OpenSSL });\n     */\n    public static encrypt(\n        cipher: typeof Cipher,\n        message: WordArray | string,\n        password: string,\n        cfg?: BufferedBlockAlgorithmConfig\n    ): CipherParams {\n        // Apply config defaults\n        const config = Object.assign({}, this.cfg, cfg);\n\n        // Check if we have a kdf\n        if(config.kdf === undefined) {\n            throw new Error('missing kdf in config');\n        }\n\n        // Derive key and other params\n        const derivedParams: CipherParams = config.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n        // Check if we have an IV\n        if(derivedParams.iv !== undefined) {\n            // Add IV to config\n            config.iv = derivedParams.iv;\n        }\n\n        // Encrypt\n        const ciphertext: CipherParams = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, config);\n\n        // Mix in derived params\n        return ciphertext.extend(derivedParams);\n    }\n\n    /**\n     * Decrypts serialized ciphertext using a password.\n     *\n     * @param cipher The cipher algorithm to use.\n     * @param ciphertext The ciphertext to decrypt.\n     * @param password The password.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return The plaintext.\n     *\n     * @example\n     *\n     *     var plaintext = PasswordBasedCipher.decrypt(AES, formattedCiphertext, 'password', { format: OpenSSL });\n     *     var plaintext = PasswordBasedCipher.decrypt(AES, ciphertextParams, 'password', { format: OpenSSL });\n     */\n    public static decrypt(\n        cipher: typeof Cipher,\n        ciphertext: CipherParams | string,\n        password: string,\n        cfg?: BufferedBlockAlgorithmConfig\n    ): WordArray {\n        // Apply config defaults\n        const config = Object.assign({}, this.cfg, cfg);\n\n        // Check if we have a kdf\n        if(config.format === undefined) {\n            throw new Error('missing format in config');\n        }\n\n        // Convert string to CipherParams\n        ciphertext = this._parse(ciphertext, config.format);\n\n        // Check if we have a kdf\n        if(config.kdf === undefined) {\n            throw new Error('the key derivation function must be set');\n        }\n\n        // Derive key and other params\n        const derivedParams = config.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\n\n        // Check if we have an IV\n        if(derivedParams.iv !== undefined) {\n            // Add IV to config\n            config.iv = derivedParams.iv;\n        }\n\n        // Decrypt\n        const plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, config);\n\n        return plaintext;\n    }\n\n    /**\n     * Converts serialized ciphertext to CipherParams,\n     * else assumed CipherParams already and returns ciphertext unchanged.\n     *\n     * @param ciphertext The ciphertext.\n     * @param format The formatting strategy to use to parse serialized ciphertext.\n     *\n     * @return The unserialized ciphertext.\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n     */\n    public static _parse(ciphertext: CipherParams | string, format: Formatter): CipherParams {\n        if(typeof ciphertext === 'string') {\n            return format.parse(ciphertext);\n        } else {\n            return ciphertext;\n        }\n    }\n}", "import { BufferedBlockAlgorithm } from './BufferedBlockAlgorithm';\nimport { WordArray } from './WordArray';\nimport { SerializableCipher } from './SerializableCipher';\nimport { PasswordBasedCipher } from './PasswordBasedCipher';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\nimport { CipherParams } from './CipherParams';\n\nexport abstract class Cipher extends BufferedBlockAlgorithm {\n    /**\n     * A constant representing encryption mode.\n     */\n    public static _ENC_XFORM_MODE = 1;\n\n    /**\n     * A constant representing decryption mode.\n     */\n    public static _DEC_XFORM_MODE = 2;\n\n    /**\n     * This cipher's key size. Default: 4 (128 bits / 32 Bits)\n     */\n    public static keySize = 4;\n\n    /**\n     * This cipher's IV size. Default: 4 (128 bits / 32 Bits)\n     */\n    public static ivSize = 4;\n\n    /**\n     * Either the encryption or decryption transformation mode constant.\n     */\n    public _xformMode: number;\n\n    /**\n     * The key.\n     */\n    public _key: WordArray;\n\n    /**\n     * Creates this cipher in encryption mode.\n     *\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return A cipher instance.\n     *\n     * @example\n     *\n     *     let cipher = AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n     */\n    public static createEncryptor(key: WordArray, cfg?: BufferedBlockAlgorithmConfig): Cipher {\n        // workaround for typescript not being able to create a abstract creator function directly\n        const thisClass: any = this;\n\n        return new thisClass(this._ENC_XFORM_MODE, key, cfg);\n    }\n\n    /**\n     * Creates this cipher in decryption mode.\n     *\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return A cipher instance.\n     *\n     * @example\n     *\n     *     let cipher = AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n     */\n    public static createDecryptor(key: WordArray, cfg?: BufferedBlockAlgorithmConfig): Cipher {\n        // workaround for typescript not being able to create a abstract creator function directly\n        const thisClass: any = this;\n\n        return new thisClass(this._DEC_XFORM_MODE, key, cfg);\n    }\n\n    /**\n     * Creates shortcut functions to a cipher's object interface.\n     *\n     * @param cipher The cipher to create a helper for.\n     *\n     * @return An object with encrypt and decrypt shortcut functions.\n     *\n     * @example\n     *\n     *     let AES = Cipher._createHelper(AESAlgorithm);\n     */\n    public static _createHelper(cipher: typeof Cipher) {\n        function encrypt(message: WordArray | string, key: WordArray | string, cfg?: BufferedBlockAlgorithmConfig) {\n            if(typeof key === 'string') {\n                return PasswordBasedCipher.encrypt(cipher, message, key, cfg);\n            } else {\n                return SerializableCipher.encrypt(cipher, message, key, cfg);\n            }\n        }\n\n        function decrypt(ciphertext: CipherParams | string, key: WordArray | string, cfg?: BufferedBlockAlgorithmConfig) {\n            if(typeof key === 'string') {\n                return PasswordBasedCipher.decrypt(cipher, ciphertext, key, cfg);\n            } else {\n                return SerializableCipher.decrypt(cipher, ciphertext, key, cfg);\n            }\n        }\n\n        return {\n            encrypt: encrypt,\n            decrypt: decrypt\n        };\n    }\n\n    /**\n     * Initializes a newly created cipher.\n     *\n     * @param xformMode Either the encryption or decryption transormation mode constant.\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @example\n     *\n     *     let cipher = AES.create(AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n     */\n    public constructor(xformMode: number, key: WordArray, cfg?: BufferedBlockAlgorithmConfig) {\n        // Apply config defaults\n        super(Object.assign({\n            blockSize: 1\n        }, cfg));\n\n        // Store transform mode and key\n        this._xformMode = xformMode;\n        this._key = key;\n\n        // Set initial values\n        this.reset();\n    }\n\n    /**\n     * Adds data to be encrypted or decrypted.\n     *\n     * @param dataUpdate The data to encrypt or decrypt.\n     *\n     * @return The data after processing.\n     *\n     * @example\n     *\n     *     let encrypted = cipher.process('data');\n     *     let encrypted = cipher.process(wordArray);\n     */\n    public process(dataUpdate: WordArray | string): WordArray {\n        // Append\n        this._append(dataUpdate);\n\n        // Process available blocks\n        return this._process();\n    }\n\n    /**\n     * Finalizes the encryption or decryption process.\n     * Note that the finalize operation is effectively a destructive, read-once operation.\n     *\n     * @param dataUpdate The final data to encrypt or decrypt.\n     *\n     * @return The data after final processing.\n     *\n     * @example\n     *\n     *     var encrypted = cipher.finalize();\n     *     var encrypted = cipher.finalize('data');\n     *     var encrypted = cipher.finalize(wordArray);\n     */\n    public finalize(dataUpdate?: WordArray | string): WordArray {\n        // Final data update\n        if(dataUpdate) {\n            this._append(dataUpdate);\n        }\n\n        // Perform concrete-cipher logic\n        const finalProcessedData = this._doFinalize();\n\n        return finalProcessedData;\n    }\n\n    /**\n     * Cipher specific finalize function explicitly implemented in the derived class.\n     */\n    public abstract _doFinalize(): WordArray;\n}", "import { BlockCipher } from '../lib/BlockCipher';\nimport { BlockCipherMode } from './BlockCipherMode';\n\nexport abstract class BlockCipherModeAlgorithm {\n    public _cipher!: BlockCipher;\n\n    public _iv: Array<number> | undefined;\n\n    public __creator: ((cipher: BlockCipher, iv: number[]) => BlockCipherMode) | undefined;\n\n    public constructor(cipher: BlockCipher, iv: Array<number>) {\n        this.init(cipher, iv);\n    }\n\n    /**\n     * Initializes a newly created mode.\n     *\n     * @param cipher A block cipher instance.\n     * @param iv The IV words.\n     *\n     * @example\n     *\n     *     var mode = CBC.Encryptor.create(cipher, iv.words);\n     */\n    public init(cipher: BlockCipher, iv?: Array<number>) {\n        this._cipher = cipher;\n        this._iv = iv;\n    }\n\n    public abstract processBlock(words: Array<number>, offset: number): void;\n}", "import { BlockCipher } from '../lib/BlockCipher';\nimport { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport abstract class BlockCipherMode {\n    public static Encryptor: any = BlockCipherModeAlgorithm;\n\n    public static Decryptor: any = BlockCipherModeAlgorithm;\n\n    /**\n     * Creates this mode for encryption.\n     *\n     * @param cipher A block cipher instance.\n     * @param iv The IV words.\n     *\n     * @example\n     *\n     *     var mode = CBC.createEncryptor(cipher, iv.words);\n     */\n    public static createEncryptor(cipher: BlockCipher, iv: Array<number>): BlockCipherModeAlgorithm {\n        // workaround for typescript not being able to create a abstract creator function directly\n        const encryptorClass: any = this.Encryptor;\n\n        return new encryptorClass(cipher, iv);\n    }\n\n    /**\n     * Creates this mode for decryption.\n     *\n     * @param cipher A block cipher instance.\n     * @param iv The IV words.\n     *\n     * @example\n     *\n     *     var mode = CBC.createDecryptor(cipher, iv.words);\n     */\n    public static createDecryptor(cipher: BlockCipher, iv: Array<number>): BlockCipherModeAlgorithm {\n        // workaround for typescript not being able to create a abstract creator function directly\n        const decryptorClass: any = this.Decryptor;\n\n        return new decryptorClass(cipher, iv);\n    }\n}", "import { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport class CBCEncryptor extends BlockCipherModeAlgorithm {\n    public _prevBlock: Array<number> | undefined;\n\n    /**\n     * Processes the data block at offset.\n     *\n     * @param words The data words to operate on.\n     * @param offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: Array<number>, offset: number) {\n        // Check if we have a blockSize\n        if(this._cipher.cfg.blockSize === undefined) {\n            throw new Error('missing blockSize in cipher config');\n        }\n\n        // XOR and encrypt\n        this.xorBlock(words, offset, this._cipher.cfg.blockSize);\n        this._cipher.encryptBlock(words, offset);\n\n        // Remember this block to use with next block\n        this._prevBlock = words.slice(offset, offset + this._cipher.cfg.blockSize);\n    }\n\n    public xorBlock(words: Array<number>, offset: number, blockSize: number) {\n        // Choose mixing block\n        let block;\n        if(this._iv) {\n            block = this._iv;\n\n            // Remove IV for subsequent blocks\n            this._iv = undefined;\n        } else {\n            block = this._prevBlock;\n        }\n\n        // block should never be undefined but we want to make typescript happy\n        if(block !== undefined) {\n            // XOR blocks\n            for(let i = 0; i < blockSize; i++) {\n                words[offset + i] ^= block[i];\n            }\n        }\n    }\n}", "import { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport class CBCDecryptor extends BlockCipherModeAlgorithm {\n    public _prevBlock: Array<number> | undefined;\n\n    /**\n     * Processes the data block at offset.\n     *\n     * @param words The data words to operate on.\n     * @param offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: Array<number>, offset: number) {\n        // Check if we have a blockSize\n        if(this._cipher.cfg.blockSize === undefined) {\n            throw new Error('missing blockSize in cipher config');\n        }\n\n        // Remember this block to use with next block\n        const thisBlock = words.slice(offset, offset + this._cipher.cfg.blockSize);\n\n        // Decrypt and XOR\n        this._cipher.decryptBlock(words, offset);\n        this.xorBlock(words, offset, this._cipher.cfg.blockSize);\n\n        // This block becomes the previous block\n        this._prevBlock = thisBlock;\n    }\n\n    public xorBlock(words: Array<number>, offset: number, blockSize: number) {\n        // Choose mixing block\n        let block;\n        if(this._iv) {\n            block = this._iv;\n\n            // Remove IV for subsequent blocks\n            this._iv = undefined;\n        } else {\n            block = this._prevBlock;\n        }\n\n        // block should never be undefined but we want to make typescript happy\n        if(block !== undefined) {\n            // XOR blocks\n            for(let i = 0; i < blockSize; i++) {\n                words[offset + i] ^= block[i];\n            }\n        }\n    }\n}", "import { BlockCipherMode } from './BlockCipherMode';\nimport { CBCEncryptor } from './CBCEncryptor';\nimport { CBCDecryptor } from './CBCDecryptor';\n\n/**\n * Cipher Block Chaining mode.\n */\nexport abstract class CBC extends BlockCipherMode {\n    public static Encryptor: any = CBCEncryptor;\n\n    public static Decryptor: any = CBCDecryptor;\n}", "import { WordArray } from '../lib/WordArray';\nimport { Padding } from '../pad/Padding';\n\nexport class PKCS7 {\n    /**\n     * Pads data using the algorithm defined in PKCS #5/7.\n     *\n     * @param data The data to pad.\n     * @param blockSize The multiple that the data should be padded to.\n     *\n     * @example\n     *\n     *     PKCS7.pad(wordArray, 4);\n     */\n    public static pad(data: WordArray, blockSize: number): void {\n        // Shortcut\n        const blockSizeBytes = blockSize * 4;\n\n        // Count padding bytes\n        const nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n        // Create padding word\n        const paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n\n        // Create padding\n        const paddingWords = [];\n        for (let i = 0; i < nPaddingBytes; i += 4) {\n            paddingWords.push(paddingWord);\n        }\n        const padding = new WordArray(paddingWords, nPaddingBytes);\n\n        // Add padding\n        data.concat(padding);\n    }\n\n    /**\n     * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n     *\n     * @param data The data to unpad.\n     *\n     * @example\n     *\n     *     PKCS7.unpad(wordArray);\n     */\n    public static unpad(data: WordArray): void {\n        // Get number of padding bytes from last byte\n        const nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n        // Remove padding\n        data.sigBytes -= nPaddingBytes;\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Padding = PKCS7;", "import { Cipher } from './Cipher';\nimport { WordArray } from './WordArray';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\nimport { BlockCipherModeAlgorithm } from '../mode/BlockCipherModeAlgorithm';\nimport { CBC } from '../mode/CBC';\nimport { PKCS7 } from '../pad/PKCS7';\n\nexport abstract class BlockCipher extends Cipher {\n    public _mode!: BlockCipherModeAlgorithm;\n\n    constructor(xformMode: number, key: WordArray, cfg?: BufferedBlockAlgorithmConfig) {\n        super(xformMode, key, Object.assign({\n            // default: 128 / 32\n            blockSize: 4,\n            mode: CBC,\n            padding: PKCS7\n        }, cfg));\n    }\n\n    public reset() {\n        // Reset cipher\n        super.reset();\n\n        // Check if we have a blockSize\n        if(this.cfg.mode === undefined) {\n            throw new Error('missing mode in config');\n        }\n\n        // Reset block mode\n        let modeCreator;\n        if (this._xformMode === (<typeof BlockCipher> this.constructor)._ENC_XFORM_MODE) {\n            modeCreator = this.cfg.mode.createEncryptor;\n        } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n            modeCreator = this.cfg.mode.createDecryptor;\n            // Keep at least one block in the buffer for unpadding\n            this._minBufferSize = 1;\n        }\n\n        if (this._mode && this._mode.__creator === modeCreator) {\n            this._mode.init(this, this.cfg.iv && this.cfg.iv.words);\n        } else {\n            this._mode = modeCreator.call(this.cfg.mode, this, this.cfg.iv && this.cfg.iv.words);\n            this._mode.__creator = modeCreator;\n        }\n    }\n\n    _doProcessBlock(words: Array<number>, offset: number) {\n        this._mode.processBlock(words, offset);\n    }\n\n    _doFinalize() {\n        // Check if we have a padding strategy\n        if(this.cfg.padding === undefined) {\n            throw new Error('missing padding in config');\n        }\n\n        // Finalize\n        let finalProcessedBlocks;\n        if(this._xformMode === (<typeof BlockCipher> this.constructor)._ENC_XFORM_MODE) {\n            // Check if we have a blockSize\n            if(this.cfg.blockSize === undefined) {\n                throw new Error('missing blockSize in config');\n            }\n\n            // Pad data\n            this.cfg.padding.pad(this._data, this.cfg.blockSize);\n\n            // Process final blocks\n            finalProcessedBlocks = this._process(!!'flush');\n        } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n            // Process final blocks\n            finalProcessedBlocks = this._process(!!'flush');\n\n            // Unpad data\n            this.cfg.padding.unpad(finalProcessedBlocks);\n        }\n\n        return finalProcessedBlocks;\n    }\n\n    public abstract encryptBlock(M: Array<number>, offset: number): void;\n\n    public abstract decryptBlock(M: Array<number>, offset: number): void;\n}", "import { BlockCipher } from '../lib/BlockCipher';\nimport { WordArray } from '../lib/WordArray';\nimport { BufferedBlockAlgorithmConfig } from '../lib/BufferedBlockAlgorithmConfig';\n\n// Define lookup tables\nconst SBOX: Array<number> = [];\nconst INV_SBOX: Array<number> = [];\nconst SUB_MIX_0: Array<number> = [];\nconst SUB_MIX_1: Array<number> = [];\nconst SUB_MIX_2: Array<number> = [];\nconst SUB_MIX_3: Array<number> = [];\nconst INV_SUB_MIX_0: Array<number> = [];\nconst INV_SUB_MIX_1: Array<number> = [];\nconst INV_SUB_MIX_2: Array<number> = [];\nconst INV_SUB_MIX_3: Array<number> = [];\n\n// Compute lookup tables\n(function () {\n    // Compute double table\n    const d = [];\n    for (let i = 0; i < 256; i++) {\n        if (i < 128) {\n            d[i] = i << 1;\n        } else {\n            d[i] = (i << 1) ^ 0x11b;\n        }\n    }\n\n    // Walk GF(2^8)\n    let x = 0;\n    let xi = 0;\n    for (let i = 0; i < 256; i++) {\n        // Compute sbox\n        let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n        SBOX[x] = sx;\n        INV_SBOX[sx] = x;\n\n        // Compute multiplication\n        const x2 = d[x];\n        const x4 = d[x2];\n        const x8 = d[x4];\n\n        // Compute sub bytes, mix columns tables\n        let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n        SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n        SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n        SUB_MIX_2[x] = (t << 8)  | (t >>> 24);\n        SUB_MIX_3[x] = t;\n\n        // Compute inv sub bytes, inv mix columns tables\n        t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n        INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n        INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n        INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);\n        INV_SUB_MIX_3[sx] = t;\n\n        // Compute next counter\n        if (!x) {\n            x = xi = 1;\n        } else {\n            x = x2 ^ d[d[d[x8 ^ x2]]];\n            xi ^= d[d[xi]];\n        }\n    }\n}());\n\n// Precomputed Rcon lookup\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\nexport class AES extends BlockCipher {\n    // 256 / 32\n    public static keySize = 8;\n\n    _nRounds!: number;\n\n    _key!: WordArray;\n\n    _keyPriorReset!: WordArray;\n\n    _keySchedule!: Array<number>;\n\n    _invKeySchedule!: Array<number>;\n\n    constructor(xformMode: number, key: WordArray, cfg?: BufferedBlockAlgorithmConfig) {\n        super(xformMode, key, cfg);\n    }\n\n    reset() {\n        // reset core values\n        super.reset();\n\n        // Skip reset of nRounds has been set before and key did not change\n        if (this._nRounds && this._keyPriorReset === this._key) {\n            return;\n        }\n\n        // Shortcuts\n        const key = this._keyPriorReset = this._key;\n        const keyWords = key.words;\n        const keySize = key.sigBytes / 4;\n\n        // Compute number of rounds\n        const nRounds = this._nRounds = keySize + 6;\n\n        // Compute number of key schedule rows\n        const ksRows = (nRounds + 1) * 4;\n\n        // Compute key schedule\n        const keySchedule: Array<number> = this._keySchedule = [];\n        for (let ksRow = 0; ksRow < ksRows; ksRow++) {\n            if (ksRow < keySize) {\n                keySchedule[ksRow] = keyWords[ksRow];\n            } else {\n                let t = keySchedule[ksRow - 1];\n\n                if (!(ksRow % keySize)) {\n                    // Rot word\n                    t = (t << 8) | (t >>> 24);\n\n                    // Sub word\n                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\n                    // Mix Rcon\n                    t ^= RCON[(ksRow / keySize) | 0] << 24;\n                } else if (keySize > 6 && ksRow % keySize === 4) {\n                    // Sub word\n                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n                }\n\n                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n            }\n        }\n\n        // Compute inv key schedule\n        const invKeySchedule: Array<number> = this._invKeySchedule = [];\n        for (let invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n            const ksRow = ksRows - invKsRow;\n\n            let t;\n            if (invKsRow % 4) {\n                t = keySchedule[ksRow];\n            } else {\n                t = keySchedule[ksRow - 4];\n            }\n\n            if (invKsRow < 4 || ksRow <= 4) {\n                invKeySchedule[invKsRow] = t;\n            } else {\n                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\n                                           INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\n            }\n        }\n    }\n\n    encryptBlock(M: Array<number>, offset: number) {\n        this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\n    }\n\n    decryptBlock(M: Array<number>, offset: number) {\n        // Swap 2nd and 4th rows\n        let t = M[offset + 1];\n        M[offset + 1] = M[offset + 3];\n        M[offset + 3] = t;\n\n        this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\n\n        // Inv swap 2nd and 4th rows\n        t = M[offset + 1];\n        M[offset + 1] = M[offset + 3];\n        M[offset + 3] = t;\n    }\n\n    _doCryptBlock(\n        M: Array<number>,\n        offset: number,\n        keySchedule: Array<number>,\n        sub_mix_0: Array<number>,\n        sub_mix_1: Array<number>,\n        sub_mix_2: Array<number>,\n        sub_mix_3: Array<number>,\n        sbox: Array<number>\n    ) {\n        // Get input, add round key\n        let s0 = M[offset]     ^ keySchedule[0];\n        let s1 = M[offset + 1] ^ keySchedule[1];\n        let s2 = M[offset + 2] ^ keySchedule[2];\n        let s3 = M[offset + 3] ^ keySchedule[3];\n\n        // Key schedule row counter\n        let ksRow = 4;\n\n        // Rounds\n        for (let round = 1; round < this._nRounds; round++) {\n            // Shift rows, sub bytes, mix columns, add round key\n            const t0 = sub_mix_0[s0 >>> 24] ^ sub_mix_1[(s1 >>> 16) & 0xff] ^ sub_mix_2[(s2 >>> 8) & 0xff] ^ sub_mix_3[s3 & 0xff] ^\n                     keySchedule[ksRow++];\n            const t1 = sub_mix_0[s1 >>> 24] ^ sub_mix_1[(s2 >>> 16) & 0xff] ^ sub_mix_2[(s3 >>> 8) & 0xff] ^ sub_mix_3[s0 & 0xff] ^\n                     keySchedule[ksRow++];\n            const t2 = sub_mix_0[s2 >>> 24] ^ sub_mix_1[(s3 >>> 16) & 0xff] ^ sub_mix_2[(s0 >>> 8) & 0xff] ^ sub_mix_3[s1 & 0xff] ^\n                     keySchedule[ksRow++];\n            const t3 = sub_mix_0[s3 >>> 24] ^ sub_mix_1[(s0 >>> 16) & 0xff] ^ sub_mix_2[(s1 >>> 8) & 0xff] ^ sub_mix_3[s2 & 0xff] ^\n                     keySchedule[ksRow++];\n\n            // Update state\n            s0 = t0;\n            s1 = t1;\n            s2 = t2;\n            s3 = t3;\n        }\n\n        // Shift rows, sub bytes, add round key\n        const t0g = ((sbox[s0 >>> 24] << 24) | (sbox[(s1 >>> 16) & 0xff] << 16) | (sbox[(s2 >>> 8) & 0xff] << 8) | sbox[s3 & 0xff]) ^\n                    keySchedule[ksRow++];\n        const t1g = ((sbox[s1 >>> 24] << 24) | (sbox[(s2 >>> 16) & 0xff] << 16) | (sbox[(s3 >>> 8) & 0xff] << 8) | sbox[s0 & 0xff]) ^\n                    keySchedule[ksRow++];\n        const t2g = ((sbox[s2 >>> 24] << 24) | (sbox[(s3 >>> 16) & 0xff] << 16) | (sbox[(s0 >>> 8) & 0xff] << 8) | sbox[s1 & 0xff]) ^\n                    keySchedule[ksRow++];\n        const t3g = ((sbox[s3 >>> 24] << 24) | (sbox[(s0 >>> 16) & 0xff] << 16) | (sbox[(s1 >>> 8) & 0xff] << 8) | sbox[s2 & 0xff]) ^\n                    keySchedule[ksRow++];\n\n        // Set output\n        M[offset]     = t0g;\n        M[offset + 1] = t1g;\n        M[offset + 2] = t2g;\n        M[offset + 3] = t3g;\n    }\n}", "import { Hasher } from '../lib/Hasher';\nimport { WordArray } from '../lib/WordArray';\n\n// Initialization and round constants tables\nconst H: Array<number> = [];\nconst K: Array<number> = [];\n\n// Reusable object\nconst W: Array<number> = [];\n\nexport class SHA256 extends Hasher {\n    public _hash!: WordArray;\n\n    public reset() {\n        // reset core values\n        super.reset();\n\n        this._hash = new WordArray(H.slice(0));\n    }\n\n    public _doProcessBlock(M: Array<number>, offset: number) {\n        // Shortcut\n        const Hl = this._hash.words;\n\n        // Working variables\n        let a = Hl[0];\n        let b = Hl[1];\n        let c = Hl[2];\n        let d = Hl[3];\n        let e = Hl[4];\n        let f = Hl[5];\n        let g = Hl[6];\n        let h = Hl[7];\n\n        // Computation\n        for(let i = 0; i < 64; i++) {\n            if(i < 16) {\n                W[i] = M[offset + i] | 0;\n            } else {\n                const gamma0x = W[i - 15];\n                const gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n                              ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                               (gamma0x >>> 3);\n\n                const gamma1x = W[i - 2];\n                const gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                              ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                               (gamma1x >>> 10);\n\n                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n            }\n\n            const ch  = (e & f) ^ (~e & g);\n            const maj = (a & b) ^ (a & c) ^ (b & c);\n\n            const sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n            const sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n            const t1 = h + sigma1 + ch + K[i] + W[i];\n            const t2 = sigma0 + maj;\n\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n\n        // Intermediate hash value\n        Hl[0] = (Hl[0] + a) | 0;\n        Hl[1] = (Hl[1] + b) | 0;\n        Hl[2] = (Hl[2] + c) | 0;\n        Hl[3] = (Hl[3] + d) | 0;\n        Hl[4] = (Hl[4] + e) | 0;\n        Hl[5] = (Hl[5] + f) | 0;\n        Hl[6] = (Hl[6] + g) | 0;\n        Hl[7] = (Hl[7] + h) | 0;\n    }\n\n    public _doFinalize(): WordArray {\n        const nBitsTotal = this._nDataBytes * 8;\n        const nBitsLeft = this._data.sigBytes * 8;\n\n        // Add padding\n        this._data.words[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n        this._data.words[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n        this._data.words[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n        this._data.sigBytes = this._data.words.length * 4;\n\n        // Hash final blocks\n        this._process();\n\n        // Return final computed hash\n        return this._hash;\n    }\n}", "import { WordArray } from '../lib/WordArray';\nimport { Padding } from '../pad/Padding';\n\nexport class NoPadding {\n    /**\n     * Doesn't pad the data provided.\n     *\n     * @param data The data to pad.\n     * @param blockSize The multiple that the data should be padded to.\n     *\n     * @example\n     *\n     *     NoPadding.pad(wordArray, 4);\n     */\n    public static pad(data: WordArray, blockSize: number): void {\n    }\n\n    /**\n     * Doesn't unpad the data provided.\n     *\n     * @param data The data to unpad.\n     *\n     * @example\n     *\n     *     NoPadding.unpad(wordArray);\n     */\n    public static unpad(data: WordArray): void {\n    }\n}\n\n// type guard for the padding (to ensure it has the required static methods)\nconst _: Padding = NoPadding;", "import { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport class ECBEncryptor extends BlockCipherModeAlgorithm {\n    /**\n     * Processes the data block at offset.\n     *\n     * @param words The data words to operate on.\n     * @param offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: Array<number>, offset: number) {\n        this._cipher.encryptBlock(words, offset);\n    }\n}", "import { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport class ECBDecryptor extends BlockCipherModeAlgorithm {\n    /**\n     * Processes the data block at offset.\n     *\n     * @param words The data words to operate on.\n     * @param offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: Array<number>, offset: number) {\n        this._cipher.decryptBlock(words, offset);\n    }\n}", "import { BlockCipherMode } from './BlockCipherMode';\nimport { ECBEncryptor } from './ECBEncryptor';\nimport { ECBDecryptor } from './ECBDecryptor';\n\n/**\n * Cipher Block Chaining mode.\n */\nexport abstract class ECB extends BlockCipherMode {\n    public static Encryptor: typeof ECBEncryptor = ECBEncryptor;\n\n    public static Decryptor: typeof ECBDecryptor = ECBDecryptor;\n}", "// DEPENDENCIES ////////////////////////////////////////////////////////////////////////////////////\n\n// import indirectly referenced declarations\nimport { BufferedBlockAlgorithmConfig } from './lib/BufferedBlockAlgorithmConfig';\n\n// LIB /////////////////////////////////////////////////////////////////////////////////////////////\n\nimport { WordArray } from './lib/WordArray';\nimport { BlockCipher } from './lib/BlockCipher';\nimport { CipherParams } from './lib/CipherParams';\nimport { Hasher } from './lib/Hasher';\nimport { SerializableCipher } from './lib/SerializableCipher';\nimport { PasswordBasedCipher } from './lib/PasswordBasedCipher';\n\nexport const lib = {\n    BlockCipher: BlockCipher,\n    WordArray: WordArray,\n    CipherParams: CipherParams,\n    Hasher: Hasher,\n    SerializableCipher: SerializableCipher,\n    PasswordBasedCipher: PasswordBasedCipher\n};\n\n// ALGORITHMS //////////////////////////////////////////////////////////////////////////////////////\n\nimport { AES as AESAlgorithm } from './algo/AES';\nimport { SHA256 as SHA256Algorithm } from './algo/SHA256';\n\nexport const algo = {\n    AES: AESAlgorithm,\n    SHA256: SHA256Algorithm\n};\n\n// ENCODINGS ///////////////////////////////////////////////////////////////////////////////////////\n\nimport { Utf8 } from './enc/Utf8';\nimport { Hex } from './enc/Hex';\n\nexport const enc = {\n    Utf8: Utf8,\n    Hex: Hex\n};\n\n// PADDING /////////////////////////////////////////////////////////////////////////////////////////\n\nimport { NoPadding } from './pad/NoPadding';\nimport { PKCS7 } from './pad/PKCS7';\n\nexport const pad = {\n    NoPadding: NoPadding,\n    PKCS7: PKCS7\n};\n\n// MODES ///////////////////////////////////////////////////////////////////////////////////////////\n\nimport { CBC } from './mode/CBC';\nimport { ECB } from './mode/ECB';\n\nexport const mode = {\n    CBC: CBC,\n    ECB: ECB\n};\n\n// HELPERS /////////////////////////////////////////////////////////////////////////////////////////\n\nexport const AES = lib.BlockCipher._createHelper(algo.AES);\nexport const SHA256 = lib.Hasher._createHelper(algo.SHA256);"],
  "mappings": "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",
  "names": ["d", "b", "Hex", "WordArray", "Latin1", "Utf8", "BufferedBlockAlgorithm", "tslib_1.__extends", "CipherParams", "Base64", "OpenSSL", "SerializableCipher", "Hasher", "MD5", "H", "EvpKDF", "OpenSSLKdf", "PasswordBasedCipher", "Cipher", "BlockCipherModeAlgorithm", "BlockCipherMode", "CBCEncryptor", "CBCDecryptor", "PKCS7", "BlockCipher", "AES", "SHA256", "NoPadding", "ECBEncryptor", "ECBDecryptor"]
}
